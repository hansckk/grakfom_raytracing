<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Kamera Walkthrough</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: sans-serif;
        }
    </style>
</head>
<body>
    <div id="instructions">
        Klik untuk memulai.<br/>
        W, A, S, D: Bergerak<br/>
        Mouse: Melihat sekeliling<br/>
        ESC: Melepas kursor
    </div>
    <canvas id="myThreeJsCanvas"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        let scene, camera, renderer;
        let cube, floor;
        let clock;

        // Pengaturan kontrol
        const moveSpeed = 5.0; // unit per detik
        const lookSpeed = 0.002; // sensitivitas mouse

        const keys = {
            W: false, A: false, S: false, D: false,
            SPACE: false, SHIFT: false // Opsional untuk naik/turun
        };

        let isPointerLocked = false;
        let euler = new THREE.Euler(0, 0, 0, 'YXZ'); // YXZ order penting untuk kontrol FPS
        const PI_2 = Math.PI / 2;

        init();
        animate();

        function init() {
            // 1. Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Biru langit
            scene.fog = new THREE.Fog(0x87ceeb, 0, 100); // Tambahkan kabut

            // 2. Kamera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 1.7, 5); // Posisi awal setinggi mata orang berdiri

            // 3. Renderer
            const canvas = document.getElementById('myThreeJsCanvas');
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // Aktifkan bayangan

            // 4. Clock untuk delta time
            clock = new THREE.Clock();

            // 5. Objek (Kubus dan Lantai)
            const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
            const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0xffA500 }); // Oranye
            cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.position.set(0, 0.5, 0); // Letakkan kubus di atas lantai
            cube.castShadow = true;
            cube.receiveShadow = true;
            scene.add(cube);

            const floorGeometry = new THREE.PlaneGeometry(50, 50);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, side: THREE.DoubleSide });
            floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2; // Putar agar menjadi lantai
            floor.receiveShadow = true; // Lantai menerima bayangan
            scene.add(floor);

            // 6. Cahaya
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 15, 10);
            directionalLight.castShadow = true;
            // Konfigurasi bayangan untuk directional light
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
                            directionalLight.shadow.camera.right = 20;
                            directionalLight.shadow.camera.top = 20;
                            directionalLight.shadow.camera.bottom = -20;

            scene.add(directionalLight);

            // Helper untuk melihat shadow camera (opsional, untuk debugging)
            // const shadowCamHelper = new THREE.CameraHelper(directionalLight.shadow.camera);
            // scene.add(shadowCamHelper);


            // 7. Event Listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('pointerlockerror', () => console.error('PointerLockError'));

            canvas.addEventListener('click', () => {
                canvas.requestPointerLock();
            });

            window.addEventListener('resize', onWindowResize);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': keys.W = true; break;
                case 'KeyA': keys.A = true; break;
                case 'KeyS': keys.S = true; break;
                case 'KeyD': keys.D = true; break;
                case 'Space': keys.SPACE = true; break;
                case 'ShiftLeft': case 'ShiftRight': keys.SHIFT = true; break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': keys.W = false; break;
                case 'KeyA': keys.A = false; break;
                case 'KeyS': keys.S = false; break;
                case 'KeyD': keys.D = false; break;
                case 'Space': keys.SPACE = false; break;
                case 'ShiftLeft': case 'ShiftRight': keys.SHIFT = false; break;
            }
        }

        function onMouseMove(event) {
            if (!isPointerLocked) return;

            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;

            euler.y -= movementX * lookSpeed; // Yaw
            euler.x -= movementY * lookSpeed; // Pitch

            // Batasi pitch agar tidak terbalik (atas/bawah)
            euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));

            camera.quaternion.setFromEuler(euler);
        }

        function onPointerLockChange() {
            if (document.pointerLockElement === renderer.domElement) {
                isPointerLocked = true;
                document.getElementById('instructions').style.display = 'none';
            } else {
                isPointerLocked = false;
                document.getElementById('instructions').style.display = 'block';
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateCamera(deltaTime) {
            if (!isPointerLocked) return;

            const currentMoveSpeed = moveSpeed * deltaTime;
            const direction = new THREE.Vector3(); // Vektor arah sementara

            // Pergerakan relatif terhadap arah kamera
            if (keys.W) {
                camera.getWorldDirection(direction);
                camera.position.addScaledVector(direction, currentMoveSpeed);
            }
            if (keys.S) {
                camera.getWorldDirection(direction);
                camera.position.addScaledVector(direction, -currentMoveSpeed);
            }
            if (keys.A) {
                // Untuk strafe kiri, kita ambil vektor arah, lalu cross product dengan sumbu Y (atas)
                // Ini akan memberikan vektor yang tegak lurus ke arah pandang dan sumbu Y (yaitu, ke kiri/kanan)
                camera.getWorldDirection(direction);
                direction.cross(camera.up).normalize(); // Vektor ke kiri
                camera.position.addScaledVector(direction, -currentMoveSpeed);
            }
            if (keys.D) {
                camera.getWorldDirection(direction);
                direction.cross(camera.up).normalize(); // Vektor ke kiri, jadi kita gunakan positif untuk ke kanan
                camera.position.addScaledVector(direction, currentMoveSpeed);
            }

            // Pergerakan vertikal (opsional)
            if (keys.SPACE) {
                camera.position.y += currentMoveSpeed;
            }
            if (keys.SHIFT) {
                camera.position.y -= currentMoveSpeed;
            }

            // Menjaga kamera agar tidak masuk ke bawah lantai (contoh sederhana)
            // Anda mungkin ingin implementasi deteksi tabrakan yang lebih baik
            if (camera.position.y < 0.5) {
                camera.position.y = 0.5;
            }
        }


        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta(); // Waktu sejak frame terakhir

            // Animasi kubus (opsional)
            cube.rotation.x += 0.01 * deltaTime * 60; // Kalikan dengan 60 untuk konsistensi jika deltaTime bervariasi
            cube.rotation.y += 0.01 * deltaTime * 60;

            updateCamera(deltaTime);

            renderer.render(scene, camera);
        }

    </script>
</body>
</html>